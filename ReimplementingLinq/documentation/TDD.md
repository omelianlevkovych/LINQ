# Introduction 
Unit testing is not only about covering your code to make your cli scream - 'hey dude, you broke something', but also it serves as great documentation of your code.
If unit test passes a scenario with certain params, you can prove that the code works under those params.

## TDD
Test drive development is a methodology when writing code and tests process is reversed and you will start all development with a failig test.
Uncle Bob describes it this way:
- 1. You are not allowed to write any prod code unless you already made a failing unit test pass.
- 2. You are not allowed to write any more of unit test than it is sufficient to fail, and compilation failures are failures.
- 3. You are not allowed any more prod code than is sufficient to pass the one failig unit test.

Red-Green-Refactor!

## Prerequisite knowleadge 
 - Basics: LINQ to Objects is based on iterators. These have always been part of .NET, and indeed are the basis of the foreach statement - but with LINQ to Objects they're more important than ever before.
The iterator pattern is a common one, and in .NET it's encapsulated in the IEnumerable and IEnumerator interfaces, and their generic counterparts.
Obviously the generic form is strongly typed where the nongeneric form isn't, but the only other difference is that the generic form extends IDisposable.

The basic idea is that as a data consumer, you can ask an IEnumerable for an IEnumerator with the GetEnumerator() call, and then iterate over the contents of the IEnumerator (using the MoveNext() method and Current property) until either you no longer need any more data, or the iterator runs out information to return.
Example:
    IEnumerable<int> iterator = dataSource.GetEnumerator();
    while (iterator.MoveNext())
    {
        int data = iterator.Current();
    }
We are not going to call Dispose for the simplicity purpose. The code generated for a foreach loop uses a try/finally construct to make sure that the iterator is disposed when we've finished with it.
Why are there two interfaces involved?
You may well be asking yourself why IEnumerable doesn't have MoveNext() and Current members itself - why do we need an extra interface?
Well, imagine you had two different loops iterating over the same list. You don't want the loops to interfere with each other, so you need two independent representations of the idea of "how much of the list I've looked at so far". This concept is precisely what IEnumerator is for. Typically it keeps a separate piece of information (such as the current index in the list) as well as referring to the collection itself. Although iterators are typically used for in-memory collections.

In C# 2, the compiler does all the hard work for you when you use iterator blocks to implement either IEnumerable or IEnumerator (or the generic forms). It builds a state machine for you, and the iterator obtained effectively executes the code within the iterator block, yielding values as it goes. It's easier to demonstrate than to explain - here's a complete program:
class IteratorBlockDemo
{
    static IEnumerable<string> GetDemoEnumerable()
    {
        yield return "start";
        
        for (int i=0; i < 5; i++)
        {
            yield return i.ToString();
        }
        
        yield return "end";
    }
    
    static void Main()
    {
        foreach (string x in GetDemoEnumerable())
        {
            Console.WriteLine(x);
        }
    }
}
The output of the program is simple:
start
0
1
2
3
4
end
The flow:
 1. Main calls GetDemoEnumerable()
 2. GetDemoEnumerable() creates a new instance of the extra type generated by the compiler. None of the source code we've written executes yet.
 3. Main calls MoveNext()
 4. The iterator executes code until it reaches a yield statement. In our case, this happens immediately. The iterator remembers that the current item should be "start" and returns true to indicate that there is data available.
 5. Main uses the Current property to retrieve the data, then prints it out.
 6. Main calls MoveNext() again
 7. The iterator continues execution from the point it had previously reached - in other words, it goes to the line after the first yield return. As before, it executes code (initialising the i variable) until it reaches the next yield statement.
 8. ... The pattern repeats, until there's a call to MoveNext() which reaches the end of the method - at which point the call returns false to indicate that there's no more data available.
There are three very important (related) points here: first, that none of our original source code is executed until the first call to MoveNext(). Second, that subsequent calls to MoveNext() effectively jump back into the source code at the point they left off before. Yielding a value is sort of like "pausing" the method. Third, the compiler makes sure that the state of the method (in terms of local variables) is preserved - even though the i variable is local inside the iterator block, its value is kept inside the iterator so that next time MoveNext() is called, it can still be used.

INQ to Objects is built on the concept of a data pipeline. We start with a data source which implements IEnumerable, and chain together lots of operations, each one acting on the result of the previous one and returning another IEnumerable - although it could be one with a different type of result. This act of chaining small operations together to form one large operation is called composition. The emphasis in composition is of making each of the small operations genuinely simple. Flexibility is provided in LINQ to Objects by the use of delegates which can act on the input elements - for example, to act as a predicate in a filter, indicating whether or not a particular value should pass the filter; or as a projection to map one value to another.
Example:

from number in numbers
where number >= 0
orderby number
select number.ToString("x")

The parser translates this into a non-query expression before the compiler deals with it any further:

numbers.Where(number => number >= 0)
       .OrderBy(number => number)
       .Select(number => number.ToString("x"))
The => syntax is for lambda expressions - a simple way of creating delegates (and also expression trees). The Where, OrderBy and Select methods are extension methods provided by LINQ to Objects to do filtering, ordering and projections respectively.

 - Deferred execution vs immediate execution: Just as when we created our own iterator using iterator blocks, the expression above doesn't execute any significant code when it's executed - it sets up the pipeline, but won't actually ask for any data. It only starts doing any actual filtering/ordering/projecting when the return value of Select is first asked for some data. This is called deferred execution. Many LINQ to Objects query operators use deferred execution, especially when they're conceptually building more of a pipeline. Other query operators such as Count(), Max() and ToList() use immediate execution - which means they perform their work immediately, and give you a result with all the appropriate data.

 - Streaming vs buffering: There's another concept which is similar to deferred/immediate execution, but subtly different - and that's whether an operator streams the data or buffers it. An operator which streams data basically only asks for as much data (from the previous part of the pipeline) as it it needs to give the next result. Select() is the simplest example of this - it retrieves the next item, applies the specified delegate to project it to the result, and then yields that result. Where() is slightly more complicated - it will keep asking for more data until either there is no more data, or until it finds an element which passes its filter. When it finds a passing element, however, it will yield that value without asking for any more data.

Buffering operators act differently. When they're asked for data, they buffer up all the data from the earlier piece of the pipeline, and then work out all the results. Reverse() is the simplest example of this - in order to return all of the data in the reverse order, you've got to get to the last element before you can yield anything. Sorting and grouping also buffer data in LINQ to Objects.
## Linq reimpementation:

## Where
Source code:
public static IEnumerable<TSource> Where(
    this IEnumerable<TSource> source,
    Func<TSource, bool> predicate)

// Lets the predicate use the index withit the sequence as well as the value. The index always starts at 0, and increments by 1 each time regardless
// of previous result from the predicate.
public static IEnumerable<TSource> Where(
    this IEnumerable<TSource> source,
    Func<TSource, int, bool> predicate)

Behaviour:
 - You should not be able to modify the input sequence (source param).
 - The Where is deferred operator - until you go throw the IEnumerable, it won'tt start fetching items from the input sequence.
 - Despite deferred execution, Where will validate that the parameters are not null immediately.
 - It streams it result: it only ever needs to look at one result at a time, and will yield it without keeping a reference to it.
 This means you can apply it to an infinitely long sequence.
 - It will iterate over the input sequence exactly once each time you iterate over the output sequence.
 - Disposing of an iterator over the output sequence will dispose of the corresponding iterator over the input sequence.
 (In case you did not know, the foreach statement in C# uses a try/finally block to make sure the iterator is always disposed when loop finishes.)

## Select
public static IEnumerable<TResult> Select<TSource, TResult>(
    this IEnumerable<TSource> source,
    Func<TSouce, TResult> selector)

public static IEnumeralbe<TResult> Select<TSource, TResult>(
    this IEnumerable<TSource> source,
    Func<TSource, int, TResult> selector)

Behaviour:
 - The operator extrapolate one sequence to another: the 'selector' delegate is applied to each input to yield the output element.
 - You should not be able to modify the input sequence (source param).
 - The Where is deferred operator - until you go throw the IEnumerable, it won'tt start fetching items from the input sequence.
 - Despite deferred execution, Where will validate that the parameters are not null immediately.
 - It streams it result: it only ever needs to look at one result at a time, and will yield it without keeping a reference to it.
 This means you can apply it to an infinitely long sequence.
 - It will iterate over the input sequence exactly once each time you iterate over the output sequence.
 - Disposing of an iterator over the output sequence will dispose of the corresponding iterator over the input sequence.

## Range
public static IEnumerable<int> Range(
    int start,
    int count)

Generates a sequence of integral numbers within a specified range.

## Empty
public static IEnumerable<TResult> Empty<TResult>()

Returns an empty sequence of the appropriate type.
Empty does cahce an empty sequence.

## Conclusion
 - Linq to Object is based on extension methods, delegates and IEnumerable<T>.
 - Operator do not mutate the original source, but instead return a new sequence which will return the appropriate data.
 - Query expressions are based on compiler translations (no need additional implementation for query).
